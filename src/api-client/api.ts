/* tslint:disable */
/* eslint-disable */
/**
 * Orbital Backend
 * Backend for the orbital
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BotChatDto
 */
export interface BotChatDto {
    /**
     * ID of the task for which the bot is generating a response
     * @type {string}
     * @memberof BotChatDto
     */
    'task_id': string;
    /**
     * Message sent to the bot
     * @type {string}
     * @memberof BotChatDto
     */
    'message': string;
    /**
     * Optional context to guide the botâ€™s response
     * @type {ChatContextDto}
     * @memberof BotChatDto
     */
    'context'?: ChatContextDto;
}
/**
 * 
 * @export
 * @interface BulkUpdateTaskStatusDto
 */
export interface BulkUpdateTaskStatusDto {
    /**
     * Array of task IDs to update
     * @type {Array<string>}
     * @memberof BulkUpdateTaskStatusDto
     */
    'task_ids': Array<string>;
    /**
     * New status to apply. Valid values: draft, design, in_review, to_do, in_progress, completed
     * @type {string}
     * @memberof BulkUpdateTaskStatusDto
     */
    'status': string;
    /**
     * Optional list of user IDs to assign to each task
     * @type {Array<string>}
     * @memberof BulkUpdateTaskStatusDto
     */
    'assignees'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ChatContextDto
 */
export interface ChatContextDto {
    /**
     * Whether to include detailed task info in the bot response
     * @type {boolean}
     * @memberof ChatContextDto
     */
    'include_task_details'?: boolean;
    /**
     * Whether to include recent chat messages in the bot context
     * @type {boolean}
     * @memberof ChatContextDto
     */
    'include_recent_messages'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateConversationalProjectDto
 */
export interface CreateConversationalProjectDto {
    /**
     * Concise project requirements or goals
     * @type {string}
     * @memberof CreateConversationalProjectDto
     */
    'requirements': string;
    /**
     * Unique identifier of the parent project
     * @type {string}
     * @memberof CreateConversationalProjectDto
     */
    'project_id': string;
    /**
     * Whether the system should automatically generate tasks from the requirements
     * @type {boolean}
     * @memberof CreateConversationalProjectDto
     */
    'auto_create_tasks'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateMessageDto
 */
export interface CreateMessageDto {
    /**
     * The actual content of the message
     * @type {string}
     * @memberof CreateMessageDto
     */
    'content': string;
    /**
     * Type of the message. One of: text, image, code
     * @type {string}
     * @memberof CreateMessageDto
     */
    'type'?: string;
    /**
     * List of user mentions in the message
     * @type {Array<string>}
     * @memberof CreateMessageDto
     */
    'mentions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * Name of the project being created
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
    /**
     * Short description of the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'description'?: string;
    /**
     * The github URL of the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'repoUrl'?: string;
    /**
     * Type of the project (e.g., web_development, conversational)
     * @type {string}
     * @memberof CreateProjectDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * Title of the task
     * @type {string}
     * @memberof CreateTaskDto
     */
    'title': string;
    /**
     * Optional description of the task
     * @type {string}
     * @memberof CreateTaskDto
     */
    'description'?: string;
    /**
     * Current status of the task. Valid values: draft, design, in_review, to_do, in_progress, completed
     * @type {string}
     * @memberof CreateTaskDto
     */
    'status': string;
    /**
     * Priority level of the task. One of: low, medium, high
     * @type {string}
     * @memberof CreateTaskDto
     */
    'priority'?: string;
    /**
     * List of user IDs assigned to this task
     * @type {Array<string>}
     * @memberof CreateTaskDto
     */
    'assignees'?: Array<string>;
    /**
     * Estimated number of hours to complete the task
     * @type {number}
     * @memberof CreateTaskDto
     */
    'estimated_hours'?: number;
}
/**
 * 
 * @export
 * @interface CreateTemplateDto
 */
export interface CreateTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateDto
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateDto
     */
    'systemPrompt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateDto
     */
    'userPrompt': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * Auth provider user ID
     * @type {string}
     * @memberof CreateUserDto
     */
    'auth_id': string;
    /**
     * Full name
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
    /**
     * Email
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * Avatar URL
     * @type {string}
     * @memberof CreateUserDto
     */
    'avatar'?: string;
    /**
     * Initial user status
     * @type {string}
     * @memberof CreateUserDto
     */
    'status'?: CreateUserDtoStatusEnum;
}

export const CreateUserDtoStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type CreateUserDtoStatusEnum = typeof CreateUserDtoStatusEnum[keyof typeof CreateUserDtoStatusEnum];

/**
 * 
 * @export
 * @interface ProjectAnalysisDto
 */
export interface ProjectAnalysisDto {
    /**
     * Requirements for the AI to analyze
     * @type {string}
     * @memberof ProjectAnalysisDto
     */
    'requirements': string;
    /**
     * Optional context like budget, timeline, platform, etc.
     * @type {object}
     * @memberof ProjectAnalysisDto
     */
    'context'?: object;
}
/**
 * 
 * @export
 * @interface TaskExecutionLog
 */
export interface TaskExecutionLog {
    /**
     * 
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'message_id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'task_id': string;
    /**
     * Log status
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'status': TaskExecutionLogStatusEnum;
    /**
     * Type of log entry
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'type'?: TaskExecutionLogTypeEnum;
    /**
     * Human-readable log content to show on frontend
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskExecutionLog
     */
    'timestamp': string;
}

export const TaskExecutionLogStatusEnum = {
    SandboxReused: 'sandbox_reused',
    SandboxCreated: 'sandbox_created',
    InProgress: 'in_progress',
    Processing: 'processing',
    Completed: 'completed',
    Error: 'error',
    Agent: 'agent',
    File: 'file',
    FileRead: 'file_read',
    FileReadError: 'file_read_error',
    Command: 'command',
    Stdout: 'stdout',
    Stderr: 'stderr'
} as const;

export type TaskExecutionLogStatusEnum = typeof TaskExecutionLogStatusEnum[keyof typeof TaskExecutionLogStatusEnum];
export const TaskExecutionLogTypeEnum = {
    Agent: 'agent',
    Sandbox: 'sandbox',
    Summary: 'summary',
    AgentOutput: 'agent_output'
} as const;

export type TaskExecutionLogTypeEnum = typeof TaskExecutionLogTypeEnum[keyof typeof TaskExecutionLogTypeEnum];

/**
 * 
 * @export
 * @interface TaskGeneratedFile
 */
export interface TaskGeneratedFile {
    /**
     * 
     * @type {string}
     * @memberof TaskGeneratedFile
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGeneratedFile
     */
    'message_id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGeneratedFile
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGeneratedFile
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGeneratedFile
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface TaskResponseDto
 */
export interface TaskResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'priority': string;
    /**
     * 
     * @type {number}
     * @memberof TaskResponseDto
     */
    'progress': number;
    /**
     * 
     * @type {number}
     * @memberof TaskResponseDto
     */
    'estimated_hours': number;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'due_date': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TaskResponseDto
     */
    'ai_generated': boolean;
    /**
     * 
     * @type {number}
     * @memberof TaskResponseDto
     */
    'ai_confidence': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskResponseDto
     */
    'assignees': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDto
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface UpdateTaskStatusDto
 */
export interface UpdateTaskStatusDto {
    /**
     * New status to apply. Valid values: draft, design, in_review, to_do, in_progress, completed
     * @type {string}
     * @memberof UpdateTaskStatusDto
     */
    'status': string;
    /**
     * Optional list of user IDs to assign
     * @type {Array<string>}
     * @memberof UpdateTaskStatusDto
     */
    'assignees'?: Array<string>;
    /**
     * Optional due date for the task in ISO format
     * @type {string}
     * @memberof UpdateTaskStatusDto
     */
    'due_date'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTemplateDto
 */
export interface UpdateTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateDto
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateDto
     */
    'systemPrompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateDto
     */
    'userPrompt'?: string;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'auth_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'status': UserResponseDtoStatusEnum;
}

export const UserResponseDtoStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type UserResponseDtoStatusEnum = typeof UserResponseDtoStatusEnum[keyof typeof UserResponseDtoStatusEnum];


/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Analyze project requirements using the ProjectBot
         * @param {ProjectAnalysisDto} projectAnalysisDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerAnalyzeProject: async (projectAnalysisDto: ProjectAnalysisDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectAnalysisDto' is not null or undefined
            assertParamExists('botsControllerAnalyzeProject', 'projectAnalysisDto', projectAnalysisDto)
            const localVarPath = `/api/v1/bots/project-planner/analyze`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectAnalysisDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a message to the bot for a task
         * @param {string} botId 
         * @param {BotChatDto} botChatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerChat: async (botId: string, botChatDto: BotChatDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerChat', 'botId', botId)
            // verify required parameter 'botChatDto' is not null or undefined
            assertParamExists('botsControllerChat', 'botChatDto', botChatDto)
            const localVarPath = `/api/v1/bots/{botId}/chat`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botChatDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all available bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific bot by ID
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerFindOne: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerFindOne', 'botId', botId)
            const localVarPath = `/api/v1/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Analyze project requirements using the ProjectBot
         * @param {ProjectAnalysisDto} projectAnalysisDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerAnalyzeProject(projectAnalysisDto: ProjectAnalysisDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerAnalyzeProject(projectAnalysisDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerAnalyzeProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send a message to the bot for a task
         * @param {string} botId 
         * @param {BotChatDto} botChatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerChat(botId: string, botChatDto: BotChatDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerChat(botId, botChatDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all available bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific bot by ID
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerFindOne(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerFindOne(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Analyze project requirements using the ProjectBot
         * @param {ProjectAnalysisDto} projectAnalysisDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerAnalyzeProject(projectAnalysisDto: ProjectAnalysisDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.botsControllerAnalyzeProject(projectAnalysisDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a message to the bot for a task
         * @param {string} botId 
         * @param {BotChatDto} botChatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerChat(botId: string, botChatDto: BotChatDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.botsControllerChat(botId, botChatDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all available bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.botsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific bot by ID
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerFindOne(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.botsControllerFindOne(botId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * 
     * @summary Analyze project requirements using the ProjectBot
     * @param {ProjectAnalysisDto} projectAnalysisDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerAnalyzeProject(projectAnalysisDto: ProjectAnalysisDto, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerAnalyzeProject(projectAnalysisDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a message to the bot for a task
     * @param {string} botId 
     * @param {BotChatDto} botChatDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerChat(botId: string, botChatDto: BotChatDto, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerChat(botId, botChatDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all available bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerFindAll(options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific bot by ID
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerFindOne(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerFindOne(botId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a new message in a task chat
         * @param {string} taskId 
         * @param {CreateMessageDto} createMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatControllerCreate: async (taskId: string, createMessageDto: CreateMessageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('chatControllerCreate', 'taskId', taskId)
            // verify required parameter 'createMessageDto' is not null or undefined
            assertParamExists('chatControllerCreate', 'createMessageDto', createMessageDto)
            const localVarPath = `/api/v1/tasks/{taskId}/messages`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all messages for a task chat
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatControllerFindAll: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('chatControllerFindAll', 'taskId', taskId)
            const localVarPath = `/api/v1/tasks/{taskId}/messages`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send a new message in a task chat
         * @param {string} taskId 
         * @param {CreateMessageDto} createMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatControllerCreate(taskId: string, createMessageDto: CreateMessageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatControllerCreate(taskId, createMessageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all messages for a task chat
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatControllerFindAll(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatControllerFindAll(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * 
         * @summary Send a new message in a task chat
         * @param {string} taskId 
         * @param {CreateMessageDto} createMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatControllerCreate(taskId: string, createMessageDto: CreateMessageDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.chatControllerCreate(taskId, createMessageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all messages for a task chat
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatControllerFindAll(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.chatControllerFindAll(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
    /**
     * 
     * @summary Send a new message in a task chat
     * @param {string} taskId 
     * @param {CreateMessageDto} createMessageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatControllerCreate(taskId: string, createMessageDto: CreateMessageDto, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatControllerCreate(taskId, createMessageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all messages for a task chat
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatControllerFindAll(taskId: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatControllerFindAll(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check full system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheckHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Basic status ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheckStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check full system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheckHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheckHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheckHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Basic status ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheckStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheckStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheckStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Check full system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheckHealth(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthControllerCheckHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Basic status ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheckStatus(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthControllerCheckStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Check full system health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheckHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheckHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Basic status ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheckStatus(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheckStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LiveKitApi - axios parameter creator
 * @export
 */
export const LiveKitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate a LiveKit access token
         * @param {string} roomName Room name to join
         * @param {string} identity Unique user identity
         * @param {string} [name] Optional user name
         * @param {string} [metadata] Optional user metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        livekitControllerGetToken: async (roomName: string, identity: string, name?: string, metadata?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomName' is not null or undefined
            assertParamExists('livekitControllerGetToken', 'roomName', roomName)
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('livekitControllerGetToken', 'identity', identity)
            const localVarPath = `/api/v1/livekit/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roomName !== undefined) {
                localVarQueryParameter['roomName'] = roomName;
            }

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveKitApi - functional programming interface
 * @export
 */
export const LiveKitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveKitApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate a LiveKit access token
         * @param {string} roomName Room name to join
         * @param {string} identity Unique user identity
         * @param {string} [name] Optional user name
         * @param {string} [metadata] Optional user metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async livekitControllerGetToken(roomName: string, identity: string, name?: string, metadata?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.livekitControllerGetToken(roomName, identity, name, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveKitApi.livekitControllerGetToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveKitApi - factory interface
 * @export
 */
export const LiveKitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveKitApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate a LiveKit access token
         * @param {string} roomName Room name to join
         * @param {string} identity Unique user identity
         * @param {string} [name] Optional user name
         * @param {string} [metadata] Optional user metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        livekitControllerGetToken(roomName: string, identity: string, name?: string, metadata?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.livekitControllerGetToken(roomName, identity, name, metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveKitApi - object-oriented interface
 * @export
 * @class LiveKitApi
 * @extends {BaseAPI}
 */
export class LiveKitApi extends BaseAPI {
    /**
     * 
     * @summary Generate a LiveKit access token
     * @param {string} roomName Room name to join
     * @param {string} identity Unique user identity
     * @param {string} [name] Optional user name
     * @param {string} [metadata] Optional user metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveKitApi
     */
    public livekitControllerGetToken(roomName: string, identity: string, name?: string, metadata?: string, options?: RawAxiosRequestConfig) {
        return LiveKitApiFp(this.configuration).livekitControllerGetToken(roomName, identity, name, metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreate: async (createProjectDto: CreateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectsControllerCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new conversational project with requirements
         * @param {CreateConversationalProjectDto} createConversationalProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreateConversational: async (createConversationalProjectDto: CreateConversationalProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createConversationalProjectDto' is not null or undefined
            assertParamExists('projectsControllerCreateConversational', 'createConversationalProjectDto', createConversationalProjectDto)
            const localVarPath = `/api/v1/projects/conversational`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConversationalProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerFindOne', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerRemove', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerUpdate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerUpdate', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerCreate(createProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new conversational project with requirements
         * @param {CreateConversationalProjectDto} createConversationalProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerCreateConversational(createConversationalProjectDto: CreateConversationalProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerCreateConversational(createConversationalProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerCreateConversational']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerUpdate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsControllerCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new conversational project with requirements
         * @param {CreateConversationalProjectDto} createConversationalProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreateConversational(createConversationalProjectDto: CreateConversationalProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsControllerCreateConversational(createConversationalProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerUpdate(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsControllerUpdate(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new conversational project with requirements
     * @param {CreateConversationalProjectDto} createConversationalProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerCreateConversational(createConversationalProjectDto: CreateConversationalProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerCreateConversational(createConversationalProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindAll(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a project by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerUpdate(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerUpdate(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bulk update status of tasks within a project
         * @param {string} projectId 
         * @param {BulkUpdateTaskStatusDto} bulkUpdateTaskStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerBulkUpdateStatus: async (projectId: string, bulkUpdateTaskStatusDto: BulkUpdateTaskStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tasksControllerBulkUpdateStatus', 'projectId', projectId)
            // verify required parameter 'bulkUpdateTaskStatusDto' is not null or undefined
            assertParamExists('tasksControllerBulkUpdateStatus', 'bulkUpdateTaskStatusDto', bulkUpdateTaskStatusDto)
            const localVarPath = `/api/v1/projects/{projectId}/tasks/bulk-status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpdateTaskStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new task under a project
         * @param {string} projectId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreate: async (projectId: string, createTaskDto: CreateTaskDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tasksControllerCreate', 'projectId', projectId)
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('tasksControllerCreate', 'createTaskDto', createTaskDto)
            const localVarPath = `/api/v1/projects/{projectId}/tasks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all tasks under a project
         * @param {string} projectId 
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindAllByProject: async (projectId: string, status: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tasksControllerFindAllByProject', 'projectId', projectId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('tasksControllerFindAllByProject', 'status', status)
            const localVarPath = `/api/v1/projects/{projectId}/tasks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a task by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerFindOne', 'id', id)
            const localVarPath = `/api/v1/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all execution logs for a task message
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetExecutionLogs: async (messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('tasksControllerGetExecutionLogs', 'messageId', messageId)
            const localVarPath = `/api/v1/tasks/execution-logs/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all generated files for a task message
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetGeneratedFiles: async (messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('tasksControllerGetGeneratedFiles', 'messageId', messageId)
            const localVarPath = `/api/v1/tasks/generated-files/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a task by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerRemove', 'id', id)
            const localVarPath = `/api/v1/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update status of a single task
         * @param {string} id 
         * @param {UpdateTaskStatusDto} updateTaskStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdateStatus: async (id: string, updateTaskStatusDto: UpdateTaskStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerUpdateStatus', 'id', id)
            // verify required parameter 'updateTaskStatusDto' is not null or undefined
            assertParamExists('tasksControllerUpdateStatus', 'updateTaskStatusDto', updateTaskStatusDto)
            const localVarPath = `/api/v1/tasks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bulk update status of tasks within a project
         * @param {string} projectId 
         * @param {BulkUpdateTaskStatusDto} bulkUpdateTaskStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerBulkUpdateStatus(projectId: string, bulkUpdateTaskStatusDto: BulkUpdateTaskStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerBulkUpdateStatus(projectId, bulkUpdateTaskStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerBulkUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new task under a project
         * @param {string} projectId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerCreate(projectId: string, createTaskDto: CreateTaskDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerCreate(projectId, createTaskDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all tasks under a project
         * @param {string} projectId 
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerFindAllByProject(projectId: string, status: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerFindAllByProject(projectId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerFindAllByProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a task by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all execution logs for a task message
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerGetExecutionLogs(messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskExecutionLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerGetExecutionLogs(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerGetExecutionLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all generated files for a task message
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerGetGeneratedFiles(messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskGeneratedFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerGetGeneratedFiles(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerGetGeneratedFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a task by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update status of a single task
         * @param {string} id 
         * @param {UpdateTaskStatusDto} updateTaskStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerUpdateStatus(id: string, updateTaskStatusDto: UpdateTaskStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerUpdateStatus(id, updateTaskStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksControllerUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Bulk update status of tasks within a project
         * @param {string} projectId 
         * @param {BulkUpdateTaskStatusDto} bulkUpdateTaskStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerBulkUpdateStatus(projectId: string, bulkUpdateTaskStatusDto: BulkUpdateTaskStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskResponseDto>> {
            return localVarFp.tasksControllerBulkUpdateStatus(projectId, bulkUpdateTaskStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new task under a project
         * @param {string} projectId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreate(projectId: string, createTaskDto: CreateTaskDto, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponseDto> {
            return localVarFp.tasksControllerCreate(projectId, createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all tasks under a project
         * @param {string} projectId 
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindAllByProject(projectId: string, status: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.tasksControllerFindAllByProject(projectId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a task by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.tasksControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all execution logs for a task message
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetExecutionLogs(messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskExecutionLog>> {
            return localVarFp.tasksControllerGetExecutionLogs(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all generated files for a task message
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetGeneratedFiles(messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskGeneratedFile>> {
            return localVarFp.tasksControllerGetGeneratedFiles(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a task by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update status of a single task
         * @param {string} id 
         * @param {UpdateTaskStatusDto} updateTaskStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdateStatus(id: string, updateTaskStatusDto: UpdateTaskStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponseDto> {
            return localVarFp.tasksControllerUpdateStatus(id, updateTaskStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Bulk update status of tasks within a project
     * @param {string} projectId 
     * @param {BulkUpdateTaskStatusDto} bulkUpdateTaskStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerBulkUpdateStatus(projectId: string, bulkUpdateTaskStatusDto: BulkUpdateTaskStatusDto, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerBulkUpdateStatus(projectId, bulkUpdateTaskStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new task under a project
     * @param {string} projectId 
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerCreate(projectId: string, createTaskDto: CreateTaskDto, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerCreate(projectId, createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all tasks under a project
     * @param {string} projectId 
     * @param {string} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerFindAllByProject(projectId: string, status: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerFindAllByProject(projectId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a task by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all execution logs for a task message
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerGetExecutionLogs(messageId: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerGetExecutionLogs(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all generated files for a task message
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerGetGeneratedFiles(messageId: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerGetGeneratedFiles(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a task by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update status of a single task
     * @param {string} id 
     * @param {UpdateTaskStatusDto} updateTaskStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerUpdateStatus(id: string, updateTaskStatusDto: UpdateTaskStatusDto, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerUpdateStatus(id, updateTaskStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new template
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerCreate: async (createTemplateDto: CreateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTemplateDto' is not null or undefined
            assertParamExists('templatesControllerCreate', 'createTemplateDto', createTemplateDto)
            const localVarPath = `/api/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a template by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templatesControllerFindOne', 'id', id)
            const localVarPath = `/api/v1/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a template by ID
         * @param {string} id 
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerUpdate: async (id: string, updateTemplateDto: UpdateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templatesControllerUpdate', 'id', id)
            // verify required parameter 'updateTemplateDto' is not null or undefined
            assertParamExists('templatesControllerUpdate', 'updateTemplateDto', updateTemplateDto)
            const localVarPath = `/api/v1/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new template
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesControllerCreate(createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesControllerCreate(createTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a template by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a template by ID
         * @param {string} id 
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesControllerUpdate(id: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesControllerUpdate(id, updateTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new template
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerCreate(createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesControllerCreate(createTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a template by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a template by ID
         * @param {string} id 
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesControllerUpdate(id: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesControllerUpdate(id, updateTemplateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new template
     * @param {CreateTemplateDto} createTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesControllerCreate(createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesControllerCreate(createTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesControllerFindAll(options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a template by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a template by ID
     * @param {string} id 
     * @param {UpdateTemplateDto} updateTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesControllerUpdate(id: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesControllerUpdate(id, updateTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('usersControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerFindOne', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all tasks assigned to a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserTasks: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerGetUserTasks', 'id', id)
            const localVarPath = `/api/v1/users/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all tasks assigned to a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUserTasks(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserTasks(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUserTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.usersControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.usersControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.usersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all tasks assigned to a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserTasks(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskResponseDto>> {
            return localVarFp.usersControllerGetUserTasks(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindAll(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all tasks assigned to a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUserTasks(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUserTasks(id, options).then((request) => request(this.axios, this.basePath));
    }
}



